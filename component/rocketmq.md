# [首页](/blog/)

> RocketMQ

## [主从同步](/rocketmq/ha)

***

## 概念及模型

### 消息生产

- **生产者（Producer）**：业务系统中用来构建并传输消息到服务端的运行实体。**从5.0版本开始，生产者是匿名无身份的。**

### 消息存储

- **主题（Topic）**：消息传输和存储的**顶层容器**，使用**TopicName**做为唯一标识。

- **消息队列（MessageQueue）**：消息存储和传输的**实际容器**，使用**QueueId**做为唯一标识。**主题内部由多个队列组成**，水平拓展的能力由队列实现。

- **消息（Message）**：最小数据传输单元，具备不可变性。

- **消息类型（MessageType）**：支持的消息类型有普通消息、顺序消息、事务消息和定时/延时消息。**从5.0版本开始，支持强制校验消息类型。**

- **消息标签（MessageTag）**：主题层级之下的**细粒度**消息分类属性，消费者通过订阅特定的标签来实现细粒度过滤。

- **消息位点（MessageQueueOffset）**：消息在队列内具备顺序性存储特征，每条消息在队列中都有一个唯一的Long类型坐标，这个坐标被定义为消息位点。

### 消息消费

- **消费者分组（ConsumerGroup）**：承载**多个消费行为一致的消费者**的负载均衡分组。非运行实体，而是一个逻辑资源。用于实现消费性能的水平扩展以及高可用容灾。

- **消费者（Consumer）**：业务系统中用来接收并处理消息的**运行实体**，消费者必须被指定到某一个消费组中。

- **订阅关系（Subscription）**：**发布订阅模型**中消息过滤、重试、消费进度的规则配置。以消费者组粒度进行管理，由消费者组**动态注册**到RocketMQ服务端中，除**过滤表达式**之外都是持久的。


- **消费位点（ConsumerOffset）**：一条消息被某个消费者消费完成后不会立即从队列中删除，RocketMQ服务端会基于每个**消费者组**记录消费过的**最新**一条消息的位点，即消费位点。

### 消息传输模型

- **点对点模型**：
  - 消息匿名：上下游沟通的唯一身份就是队列，下游消费者从队列获取消息时**无法声明独立身份**。
  - 一对一通信：由于消息匿名，即消费者即使有多个，但是都没有独立的身份，因为共享队列中的每条消息只能被唯一一个消费者处理，即只能实现一对一通信。

- **发布订阅模型**：
  - 消费独立：消费方都会具备身份，即是订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。
  - 一对多通信：基于独立身份的设计，每个订阅组都可以处理同一个主题内的全部消息，因此发布订阅模型可以实现一对多通信。

###  主题

- 按业务类型合理划分主题，可考虑的角度包括：消息类型、消息业务的关联程度、消息量级大小。
- 关闭主题自动创建，主题属于顶层资源和容器，拥有独立的权限管理、可观测性指标采集和监控等能力，创建和管理主题会占用一定的系统资源。

### 队列

- 队列天然具备顺序性，并默认使用可靠存储机制，发送成功的消息能保证至少投递一次。
- 5.0版本之前，队列名称由{TopicName}+{BrokerID}+{QueueID}三元组组成；5.0版本之后则为全局唯一的字符串，和物理节点解耦。
- 消息收发的实际操作是面向队列的，每个主题的多个队列可以分布在不同的Broker上；集群中增加节点后，应该在新的节点上新增队列，后迁移旧的队列到新的节点上。

### 生产者

生产者和主题是多对多的关系，支持同一个生产者向多个主题发送消息。生产者是可以重复利用的底层资源，类似数据库的连接池。

### 消费者组

- 消费者组和主题是多对多的关系，但是也要避免消费过多的主题（不超过10个）。
- 关闭消费者组自动创建，每个消费分组都会涉及关联的消费状态、堆积信息、可观测指标和监控采集数据。
- 消费者是可以重复利用的底层资源，类似数据库的连接池，不要频繁创建和销毁。

### 订阅关系

- 订阅关系由消费者分组动态注册到服务端，可控制消息过滤规则和消费状态。
- 订阅关系的修改会导致客户端进行负载均衡调整和变更。

***

## 功能特性

### 消息生命周期

- 普通消息：
  - 初始化：消息被生产者构建完成，待发送到服务端；
  - 待消费：消息被生产者发送到服务端，对消费者可见，等待消费者消费；
  - 消费中：消息被消费者获取，服务端等待消费者提交消费结果，一定时间后服务端会发起重试处理；
  - 消费提交：消费者已提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）；服务端默认保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费；
  - 消息删除：服务端按照消息保存机制（保存时间到期或存储空间不足）滚动清理最早的消息数据，将消息从物理文件中删除。

- 定时/延时消息：
  - 初始化
  - 定时中：消息被生产者发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达；
  - 待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对消费者可见；
  - 消费中
  - 消费提交
  - 消息删除

### 实现机制

- 定时/延时消息：默认精度为1000ms秒级。

***