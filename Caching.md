# [首页](https://kingkh1995.github.io/blog/)

# 缓存常见的问题

## 一、缓存一致性

> 更新数据时需要保证缓存和数据库的数据一致性。

一般来说，缓存有以下三种模式：

- Read/Write Through
> Read Through ：只查询缓存，由缓存服务负责加载缓存；Write Through ：缓存存在则更新缓存，由缓存服务负责***同步更新***数据库；如果缓存不存在直接更新数据库。

- Write Behind Caching 更新模式
> 只操作缓存，由缓存服务自己更新数据库，与 Read/Write Through 模式区别是更新操作为***非同步***。

- Cache Aside
> 一般情况下使用的模式，同一个操作内更新缓存和数据库。

0. 先更新缓存，再更新数据库。
    
    **该操作违背了事务性隔离性原则**，写操作未提交时其他操作就可以读取到该写操作对数据的变更。

1. 先更新数据库，再更新缓存。

    ***数据库事务回滚问题***：缓存操作执行成功但是响应超时抛出异常，或者服务器宕机来不及提交事务，都会导致数据库回滚但缓存更新成功，**出现不一致**。
        
    ***并发写问题***：如果允许并发更新操作，可能数据库先更新的反而后更新缓存，数据库后更新的反而先更新缓存，**出现不一致**。


2. 先删除缓存，再更新数据库。

    ***并发读写问题***：读操作在**写操作删除缓存之后更新数据库之前**读取到旧的数据并加载缓存，出现不一致。

3. 先更新数据库，再删除缓存。

    ***并发读写问题***：读操作在**写操作之前**读取到旧的数据，并在**写操作完成之后**加载缓存，可能出现不一致，但是概率极低，因为写操作耗时一般大大超过读操作耗时，可以视为不会出现不一致。

    ***主从同步延迟问题***：**写操作完成之后但数据库主从同步完成前**，读操作从从库读取到旧数据并加载缓存，出现不一致。


### **延迟双删**
> 先删除缓存，再更新数据库，延迟一段时间再次删除缓存。

延迟删除方案：

- ***异步处理***

- ***延时队列***

- ***延迟调度***

## 二、缓存雪崩

> 大量的缓存在**同一个时刻**过期，**缓存雪崩也会导致缓存击穿**。

解决方案：

- 缓存过期时间设置随机化

## 三、缓存击穿（缓存并发）

> 大量的并发请求访问某个**缓存失效或不存在缓存**的key，会导致大量请求查询数据库和更新缓存。

解决方案：

- ***缓存预热***：预先加载缓存，缺点是适用范围比较有限，也会有一定的空间浪费。

        例如用户查询某笔订单，同时也加载该订单相关的商品信息缓存，这样如果用户去查看订单下的商品时则可以直接读取到商品信息的缓存。

- ***缓存永不过期***：对缓存不设置过期时间或者定时刷新缓存，**适合只读场景**。

        增加了系统复杂度，相当于使用了 Read Through 模式，读操作不需要负责加载缓存，由系统实现加载缓存；

        同时更新数据时会出现缓存一致性问题，因为目前公认的解决一致性问题的方案是更新数据时淘汰缓存，这就意味着缓存不会一直存在，与该方案相悖。

- ***分级缓存***：使用多层级缓存（不同级别缓存对应不同的失效时间），上层缓存失效则查询下层缓存。
        
        不仅可以避免缓存击穿，还可以提高缓存查询效率和缓存可用性，但是同样也会有缓存一致性的问题以及会大大增加系统复杂度。

        一个比较简单的实现方案：将本地内存视作一级缓存，redis服务器视作二级缓存，理论上还可以将数据库视为第三层缓存。

- ***请求串行化***：缓存不存在时，查询请求通过**获取分布式锁**或**放入有序队列**的方式，保证只会有一个查询请求打到数据库，缺点是会降低系统吞吐量。

## 缓存穿透

> 大量请求访问**缓存和数据库都不存在**的key。

解决方案：

- ***key值先验***：先对key做一定的参数合法性校验，之后才请求缓存或数据库，缺点是适用范围比较有限。

        例如若用id作为key，先判断id是否是正整数。

- ***缓存空值***：缓存空值，缺点是空间占用率高，最好设置过期时间。

- ***布隆过滤器***：有一定的误判概率，效率高，空间占用率小，**缺点是无法删除元素**。

        布隆过滤器判断存在可能会不存在，判断不存在则一定不存在。

### **布隆过滤器**

- ***RedisBloom插件***

    https://oss.redislabs.com/redisbloom/

- ***Redisson***

    使用bitmap实现布隆过滤器。

- ***Guava BloomFilter***
    
    单机实现，并且要考虑持久化的问题。

- ***布谷鸟过滤器***

    可以删除元素。
        
## 缓存热key

> **某段时间内某些key会成为访问的热点**，导致缓存服务器也无法承受。

> **分布式缓存服务器中某些key是访问的热点**，导致热点key所属节点承载的压力比其他节点大很多。

- ***基于流式计算技术的缓存热点自动发现***：使用大数据能力自动判断热点数据。

- ***使用本地缓存***：使用多级缓存方式，在本地定义一个LFU级别的缓存。

- ***全节点备份***：将热key备份到所有的节点，同时使用某种负载均衡策略分散查询请求，**缺点是实现复杂，且无法应对突发热点**。

### **热点发现解决方案**

- 有赞：https://mp.weixin.qq.com/s/BnWtbetNq076iRRZfnGRrw


## 缓存抖动

> 分布式缓存中某个节点突然发生故障导致该节点缓存不可用。

解决方案：

- ***一致性哈希算法***

- ***Redis集群哈希槽机制***

        Redis集群采用哈希槽的机制，当集群内某个主节点宕机之后，其它主节点会从宕机主节点的从节点中选取一个节点作为该槽段的新主节点。

## 熔断限流保护

系统可用性最后的壁垒，在设计缓存系统时一定要考虑好所有异常情况，同时对缓存服务器及数据库都要使用某种熔断限流保护措施。
