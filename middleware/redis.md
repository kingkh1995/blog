# [首页](/blog/)

> redis

***

## 技术内幕

纯内存存储、IO多路复用、单线程架构。

是一个事件驱动程序，服务器需要处理两类事件：文件事件和时间事件，文件事件用于处理redis和客户端之间的网络IO，时间主要用来处理定时操作。

### 文件事件处理器

分为四部分：套接字、I/O多路复用程序、文件事件分派器以及事件处理器。

- 套接字：**文件事件是对套接字操作的抽象**，每当一个套接字的操作准备就绪时，就会产生一个文件事件。
- I/O多路复用程序：负责监听多个套接字，并向文件事件派发器传递那些产生了事件的套接字，I/O多路复用程序总是会将所有产生的套接字都放到同一个队列里。
- 文件事件分派器：将套接字关联到对应的事件处理器。
- 事件处理器：包含连接应答处理器、命令请求处理器、命令回复处理器等等。

***

## 数据结构及编码方式

- string：int（整型）、embstr（简单动态字符串）、raw
- hash：ziplist、hashtable
- list：quicklist，是结合了ziplist和linkedlist的优势的数据结构，为ziplist节点组成的linkedlist。
- set：intset（整数集合）、hashtable。
- zset：ziplist、skiplist。

### *编码方式*

- embstr：键还是使用C语言的字符串，区别是记录了字符串长度，可以直接获取字符串长度（C语言字符串需要遍历）并杜绝缓存区溢出；减少内存重分配，空间预分配，惰性空间释放；二进制安全，通过长度判断是否结束而不是空字符。
- ziplist：为连续存储的顺序结构，目的是为了节省内存。虽然其复杂度为O(n)，但因为是连续的内存空间，所以可以利用CPU缓存大幅提高性能。
- skiplist：多层结构链表，相比于红黑树实现简单但占用更多的内存，查找效率可比拟二叉查找树，同时适合范围读取。

***

## 其他功能

- pipeline：用于批量执行多个命令，能有效节约RTT，相比于原生批量命令，**pipeline是非原子性的**。
- Bitmaps：位操作，底层为字符串。
- HyperLogLog：基数算法，底层为字符串。
- Geo：地理信息功能，使用geohash和zset数据结构实现。
- pub/sub：消息队列，适合可靠性要求低的简单场景。

***

## 事务

使用multi命令可开启事务，之后所有的命令会被加入一个事务队列中，所有命令均只会返回QUEUED表示命令已经入队，最后使用exec命令退出事务，此时会顺序执行事务队列中的所有命令，并返回所有结果，或使用discard命令放弃该事务，所有命令都会被丢弃。在事务开启前可以使用watch命令监听指定的键，事务执行前会检查被监听的键是否被修改，如果被修改会抛出异常，导致事务无法执行。

### *ACID*

- 原子性：不具备真正的原子性，如果命令错误则整个事务都不会执行，此场景具备原子性，但如果是运行时错误（操作错误）事务会继续执行下去无法回滚，此场景无原子性；
- 一致性：由redis保证；
- 隔离性：事务为串行执行的，故多个事务之间可以保证隔离性；
- 持久性：由redis持久化机制保证。

### *涉及到逻辑处理的事务*

- 方案：首先监听本次事务涉及到的键，然后执行查询命令执行逻辑处理确定需要执行的命令，最后开启事务执行命令。
- 分析：相当于使用了乐观锁，对键的监听能保证并发安全，缺点就是不适合高并发场景，且锁粒度过大。

***

## Lua
通过lua脚本可以执行redis命令，高效且是原子性的，同时可以被缓存以实现复用，绝大多数情况下都应该使用lua脚本替代事务。

***

## 持久化

### RDB

为当前进程数据生成快照保存，优点是恢复时间快，缺点是成本高且无法做到实时持久化。包括save和bgsave命令，save命令会阻塞redis，不建议使用；bgsave命令会fork一个子进程，只有在fork阶段才会阻塞redis，为主流方式。

#### *bgsave流程*

1. 执行bgsave，会先判断当前是否存在bgsave命令，存在则直接返回；
2. 执行fork，过程中会阻塞父进程，fork完成后，不再阻塞父线程；
3. 子进程使用copy-on-write机制与父进程共享内存，根据父进程内存生成临时快照文件，完成后原子替换原RDB文件；
4. 替换完成后发送信号通知父进程，父进程更新统计信息。

### AOF

以独立日志的方式记录每次写命令，通过重新执行AOF文件中的命令以恢复数据，用于解决持久化实时性，缺点是恢复慢。

所有写命令以**文本协议格式**追加到AOF缓冲区，根据指定的策略（一般使用everysec）将缓冲区同步到磁盘的AOF文件，同时定期会对AOF文件重写以防止文件过大。

### RDB和AOF混合

Redis 4.0 开始，使用混合持久化则AOF重写的时候会把RDB的内容写到 AOF文件的开头。

***

## 主从复制流程

1. 保存主节点信息；
1. 主从建立socket连接；
1. 发送ping命令；
1. 权限验证；
1. **同步数据集**；
1. 持续异步复制。

### **数据同步**

使用psync命令执行数据同步，分为全量复制和部分复制。

- 全量复制流程：
    1. 从节点保存主节点的运行ID和偏移量offset；
    1. 主节点执行bgsave保存RDB文件到本地，之后主节点会把写命令数据保存在复制积压缓冲区内；
    1. 主节点发送RDB文件给从节点；
    1. 从节点接受完成RDB文件后清空旧数据；
    1. 从节点加载RDB文件；
    1. 主节点把缓冲区内的数据发送给从节点。
    
- 部分复制：从节点复制主节点数据时，如果出现异常情况从节点会向主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，从节点会将保存的已复制数据的偏移量offset和主节点的运行ID发送给主节点，要求进行部分复制操作。

***

## 内存碎片

统计值为mem_fragmentation_ratio，一般不要大于1.5。产生原因有：Redis向操作系统申请的内存空间可能会大于数据实际需要的存储空间；频繁修改数据，Redis不会轻易释放空间给操作系统。

***

## 阻塞问题

- 不合理的使用命令，通过使用slowlog命令分析慢查询；
- cpu饱和，可由命令执行效率下降引起，如放宽ziplist的条件导致过度内存优化；
- 持久化阻塞，内存实例过大可能导致fork阻塞，硬盘压力过大可能导致fsync阻塞。

***

## 内存回收策略

### 过期键删除策略

- 惰性删除：读取到过期键时才删除
- 定时删除：定时删除过期的键

### 内存溢出控制策略

- noeviction：默认策略，不删除。
- volatile-lru：使用lru算法，只删除过期的键
- allkeys-lru：使用lru算法，可删除所有键
- volatile-random：随机删除，只删除过期的键
- allkeys-random：随机删除，可删除所有键
- volatile-ttl：按ttl属性排序删除，包括还没过期的数据也会提前删除
- volatile-lfu：使用lfu算法，只删除过期的键
- allkeys-lfu：使用lfu算法，可删除所有键

***

## 架构

### 哨兵

相比于主从架构，增加了哨兵节点集群（为不存储数据的redis实例）。每一个哨兵节点都会监控所有节点和其他哨兵节点，当节点失效会将其标记为下线，如果下线的是主节点，则哨兵集群中会通过半数原则推选出一个哨兵节点来完成故障转移，并通知到应用方和集群。

通过pub/sub实现，使用固定的Channel，发送消息及订阅消息，以实现哨兵之间的通信。

### 集群

由多个节点组成，包括主节点和对应的从节点，每个节点负责整体数据的一个子集，**集群中主节点才负责读写请求和集群维护**，从节点只对主节点数据和状态信息进行复制并在主节点故障时替换主节点。

使用虚拟槽分区，范围为0-16383（16k），解耦了数据和节点的关系，由节点自身维护槽的映射关系，操作只需要基于哈希槽即可，便于节点扩容和收缩，同时集群模式只允许使用0号数据库。

节点间通信使用Gossip协议，即节点间彼此不断通信交换信息，**每个节点需要额外开启一个通信端口**，并在固定的周期内根据一定的规则选择几个节点通信，追求整个集群的最终一致性。

***