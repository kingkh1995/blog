## [首页](https://kingkh1995.github.io/blog/)

### 技术内幕

#### 架构
客户端 -> 服务器（连接器-查询缓存-分析器-优化器-执行器）-> 存储引擎 -> 文件系统

#### innodb数据存储细节
依次可以分为：表空间、段、区、页、行。

- 借助缓冲池来减小CPU和磁盘速度上的差异。当查询的时候会先通过索引定位到对应的数据页，然后检测数据页是否在缓冲池内，如果在就直接返回，如果不在就去聚簇索引中通过磁盘读取对应的数据页并放入缓冲池。

- 表空间：作为存储结构的最高层，所有数据都存放在表空间中，默认情况下使用一个共享表空间。

- 段：表空间由各个段构成，包括索引段，数据段，回滚段。

- 区：段由区组成，每个区固定大小是1MB。

- 页：区由连续的页组成，每个页的大小默认为16kb，所以默认情况下一个区包括64个连续的页。
  - 是磁盘读取的最小单位，页中的用户记录行是使用链表的方式存储，所以页也包括页目录（slot），用于二分查找快速定位，每个slot包含4到8个数据行。

- 行：业中存储的具体的行记录。
  - 组成包括：变长字段长度列表、NULL标志位（如果对应的列为空则在对应的位上置为1，同时不存储该列值，也导致索引字段为空会进行额外的操作）、记录头信息、mvcc版本信息、列数据、（如果未声明主键还会存在一个内置的记录ID）。
  
#### redolog、undolog、binlog
- redolog：用来保证数据库宕机后可以通过该文件进行恢复，该文件只能顺序写，同时是环形写，会覆盖之前旧的日志（当然得保证记录的操作已被同步到磁盘才会覆盖），且记录的是物理页的操作，只有在数据库启动的时候才会读取redolog看是否需要进行恢复。

- undolog：用来实现事务回滚和mvcc，记录的和原sql相反的sql，快照读通过undolog计算到原值，事务回滚则执行undolog记录的sql，**undolog存在对应的redolog**，还有一个后台线程定时处理所有事务都不会再使用的undolog。

- binlog：用于数据同步，是由服务器写入的日志，记录的是原sql，同时是追加写不会覆盖旧记录。

#### 更新事务技术实现流程
1. 分配事务ID，开启事务，获取锁，没有获取到锁则等待；

2. 执行器先通过存储引擎找到对应的数据页，如果缓冲池有存在数据则直接取出，没有则通过主键索引从磁盘取出并放入缓冲池；

3. 在数据页内找到需要被更新的具体记录，修改后写入内存缓冲池中；

4. 存储引擎生成redolog和undolog到内存中，将redolog状态设为预提交；

5. 将redolog和undolog写入文件中并调用fsync，确保落库而不只被写入操作系统的缓存中；

6. 服务器生成binlog并写入文件中，调用fsync保证落库；

7. 事务提交，将redolog的状态改为已完成，并释放所有锁。

### MVCC

- 多版本并发控制协议，每一行数据中额外保存两列版本信息，数据版本号 db_trx_id（最后创建该数据的事务id）和回滚指针 db_roll_pt（数据删除的事务id或上一个版本的事务id）。

- 优点是在读取数据的时候，innodb几乎不用获得任何锁，提高了系统的并发度。

- 缺点是需要维护每行数据的版本信息，且在检索行时需要版本对比，降低了查询的效率，同时还需要定期清理不再需要的行版本及时回收空间。

#### readview
> 配合MVCC使用，组成：当前进行中的事务Id集合，当前事务ID，执行事务Id集合中的最小值，当前将要分配的下一个事务Id。
>> RR级别下在第一个查询时创建readview，而RC级别下每次查询都会创建一个readview，所以RR级别不会有幻读，RC级别有。

##### readview查询过程
- 取到版本链最新版本，首先判断该版本记录的trx_id与ReadView中的creator_trx_id是否相等，不相等则进行下面步骤。
  - 1. 事务版本号小于记录的最小事务号，则可读；
  - 2. 事务版本号大于记录的下一个事务号则不可读；
  - 3. 在中间，则在进行的事务号集合中二分查找，判断是否该事务是否未提交，未提交则不可见。
- 如当前版本不可见通过回滚指针顺着undolog链向上查找，重复步骤。

#### 为什么innodb引擎count(*)慢，而myisam引擎很快？

- mysiam未使用mvcc，所以每条记录只能存在有一条数据，故可以保存记录总数，所以查询很快。

- 而innodb存在mvcc，所以要全表扫描并根据版本过滤数据，故消耗很大。

### 2PL

二阶段锁，就是加锁/解锁分为两个完全不相交的阶段，加锁阶段只加锁，解锁阶段只释放锁。

### 隔离级别

- 脏读：读取其他事务未提交的数据。

- 不可重复读：前后多次读取数据内容不一致，读取到其他事务提交的数据。

- 幻读：多次读取数据的总量不一致，其他事务仍然可以新增匹配读取范围的数据。

- Read Uncommited：未提交读。

- Read Committed (RC)：提交读，当前读保证对读取到的记录加锁 (记录锁)，存在幻读现象。

- Repeatable Read (RR)：可重复读，innodb的默认隔离级别，MVCC解决了快照读的不可重复读，当前读保证对读取到的记录加锁 (记录锁)，对读取的范围加锁(间隙锁)，当前读解决了幻读现象。

- Serializable：可序列化，从MVCC并发控制退化为基于锁的并发控制，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。

### 锁

#### 1. 锁类型

- 记录锁：锁住索引，更新或删除数据需要获取排他记录锁，排他记录锁会被所有记录锁阻塞，共享记录锁只会被排他记录锁阻塞。
- 间隙锁：锁住索引的间隙，为了阻塞插入意向锁，间隙锁之间不会互相阻塞。
- next-key锁：包含记录锁和间隙锁，InnodDB RR级别加锁方式。
- 插入意向间隙锁：插入数据之前加的间隙锁，插入意向锁之间不会阻塞，也不会阻塞间隙锁。

#### 2. 锁策略

##### S锁（共享锁） lock in share mode

可以被多个事务加锁，保证数据不能被其他事务修改，**如果想要修改数据需要去申请X锁**，但存在失败的可能（被其他事务加上了S锁则无法申请到X锁），**适用于无需修改数据只需保证数据不被修改的情景**。

##### X锁（排他锁）select for update

只能由一个事务加锁，因此数据不能被其他事务修改只能自身事务修改，**适用于需要修改数据的情景**。

##### 意向锁

“表明”加锁的意图，完全由数据库完成，处理行锁和表锁之间的矛盾，申请行锁要先申请表的意向共享锁，成功后再申请一行的行锁，这样申请表锁时不需要逐行判断表锁是否存在，只需要先判断是否存在其他表锁，再判断是否存在意向锁。

#### 3. RR级别下SQL加锁行为

- 快照读：不加任何类型的锁

- select ... from lock in share mode：在扫描到的任何索引记录上加共享的next-key锁，还在主键聚集索引加排它的记录锁。

- select ... from for update / update ... where / delete from ... where：在扫描到的任何索引记录上加排它的next-key锁，还在主键聚集索引加排它的记录锁。
    - update和delete操作在执行前都会先执行一个当前读操作
    - 如果过滤条件无法使用索引，因为加锁是引擎层面的行为，会将所有记录加上间隙锁和记录锁后返回，**不过mysql会有优化，过滤数据后会释放掉不匹配行的记录锁。虽然这明显违背了2PL**。
- insert into：在insert操作之前，会在索引记录之间加一个插入意向间隙锁，插入成功后会对插入行的索引记录上加一个排它记录锁。
    - inser操作会触发主键唯一检测，所以也会在插入前执行一个当前读。
    - **插入意向间隙锁目的是为了被间隙锁阻塞，插入意向间隙锁之间不会阻塞**。
    - 自增列innodb会在该索引的末位加一个排它锁，而为了访问这个自增的数值，需要加一个表级锁，不过这个表级锁的持续时间只有当前sql，而不是整个事务，即当前sql执行完，该表级锁就释放了，**不过最新版本改为使用互斥量实现，提高了效率**。

##### 4. 组合索引加锁

- **idx(a,b)**
- **a** : 1 | 3 | 3 | 3 | 3 | 5
- **b** : 1 | 1 | 2 | 2 | 3 | 5
- **c** : 1 | 2 | 3 | 1 | 4 | 5
- **id**: 3 | 5 | 1 | 2 | 4 | 6

1. delete from t where a>1 and a<5 and b=2 and c=1：组合索引上，gap锁5个（a值1到5之间），X锁两个（b=2），聚簇索引X锁两个（id=1,2）

2. delete from t where a=3 and b>1 and b < 3 and c=1：组合索引上，gap锁3个（a值等于3且b值大于1小于3），X锁两个（b=2），聚簇索引X锁两个（id=1,2）

#### 索引

#### 1. 索引类型

- B树索引
    - 使用B+树实现，有序存储，一般为1-3层，即可存储千万级的数据，非叶子结点只保存索引值，在叶子结点才保存被索引的数据。
    - 优点是减少了磁盘IO的次数，且每次查询都是稳定的，因为数据行到根节点的高度是相同的。

- 哈希索引
    - 使用哈希表实现，无序存储，查询快，但无法排序和范围搜索。
    - innnodb的自适应哈希索引，引擎会自发的在B树索引基础上对被频繁使用的索引值创建一个哈希索引，提高查找效率。

#### 2. 索引策略

- 聚簇索引：一种数据存储方式，将数据行和索引保存在一起，而不是通过指针指向数据行。
    - 一张表只能有一个聚簇索引，因为无法将数据同时保存在两个地方。
    - innodb的主键索引是聚簇索引，将数据行保存在B树索引的叶子结点中。
    - 优点是使用聚簇索引获取数据很快，缺点是更新聚簇索引的代价很高，会导致“页分裂”。

- 非聚簇索引：也称为二级索引，普通索引
    - innodb的二级索引在叶子结点保存的是主键值而不是指向行的指针，所以通过二级索引查找数据时需要两次b树查找。

- 唯一索引：索引值必须是唯一的，可以为Null，而主键索引不能为Null。

- 组合索引：多列索引
    - 将区分度高的索引放在左边，相当于建立了从最左列开始组合的多个多列索引。

- 覆盖索引：索引覆盖了查询的所有数据行，则不需要再去读取数据行，直接读取索引数据。

- 前缀索引：针对字符串列的索引不需要索引完整的字符串，只索引字符串前几位，以提升索引效率。
    - 对字符串字段使用前缀索引，且只能使用右模糊，因为左模糊无法使用索引。

### SQL优化

##### 字段某些特殊值占据了绝大部分的比例

``` text
status字段中值为0的数据比例超过90%，则status=0时强制不走索引idx_staus，因为加载该索引消耗更大。
select * from t ignore index (idx_stauts) where status = 0 limit 10;
```

##### 取出每个科目分数排名前2的数据

``` text
使用子查询
select * from 
table t0 
where (
    select count(*) from 
    table t1 
    where 
    t1.subject = t0.subject and t1.score > t0.score
    ) < 2

使用exists
select * from
table t0
where exists (
    select 1 from 
    table t1
    where 
    t1.subject = t0.subject and t1.score > t0.score
    having count(*) < 2)

以上两种方式是一样的，主表都是走全表查询，子查询会走subject索引
```
