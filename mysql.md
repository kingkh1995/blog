## [首页](https://kingkh1995.github.io/blog/)

### MVCC

多版本并发控制协议，每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和被删除时的版本号，其实还有一列称为回滚指针，用于事务回滚。

- 快照读：简单的select操作，属于快照读，不加锁。
- 当前读：特殊的读操作，插入/更新/删除操作（更新删除操作前会先发起一个当前读），需要加锁。

### 2PL

二阶段锁，就是加锁/解锁分为两个完全不相交的阶段，加锁阶段只加锁，解锁阶段只释放锁。

### 隔离级别

- 脏读：读取其他事务未提交的数据。

- 不可重复读：前后多次读取数据内容不一致，读取到其他事务提交的数据。

- 幻读：多次读取数据的总量不一致，其他事务仍然可以新增匹配读取范围的数据。

- Read Uncommited：未提交读。

- Read Committed (RC)：提交读，当前读保证对读取到的记录加锁 (记录锁)，存在幻读现象。

- Repeatable Read (RR)：可重复读，innodb的默认隔离级别，MVCC解决了快照读的不可重复读，当前读保证对读取到的记录加锁 (记录锁)，对读取的范围加锁(间隙锁)
  ，当前读解决了幻读现象。

- Serializable：可序列化，从MVCC并发控制退化为基于锁的并发控制，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。

### 锁

#### 1. 锁类型

- 记录锁：锁住索引，更新或删除数据需要获取排他记录锁，排他记录锁会被所有记录锁阻塞，共享记录锁只会被排他记录锁阻塞。
- 间隙锁：锁住索引的间隙，为了阻塞插入意向锁，间隙锁之间不会互相阻塞。
- next-key锁：包含记录锁和间隙锁，InnodDB RR级别加锁方式。
- 插入意向间隙锁：插入数据之前加的间隙锁，插入意向锁之间不会阻塞，也不会阻塞间隙锁。

#### 2. 锁策略

##### S锁（共享锁） lock in share mode

可以被多个事务加锁，保证数据不能被其他事务修改，**如果想要修改数据需要去申请X锁**，但存在失败的可能（被其他事务加上了S锁则无法申请到X锁），**适用于无需修改数据只需保证数据不被修改的情景**。

##### X锁（排他锁）select for update

只能由一个事务加锁，因此数据不能被其他事务修改只能自身事务修改，**适用于需要修改数据的情景**。

##### 意向锁

“表明”加锁的意图，完全由数据库完成，处理行锁和表锁之间的矛盾，申请行锁要先申请表的意向共享锁，成功后再申请一行的行锁，这样申请表锁时不需要逐行判断表锁是否存在，只需要先判断是否存在其他表锁，再判断是否存在意向锁。

#### 3. RR级别下SQL加锁行为

- 快照读：不加任何类型的锁

- select ... from lock in share mode：在扫描到的任何索引记录上加共享的next-key锁，还在主键聚集索引加排它的记录锁。

- select ... from for update / update ... where / delete from ...
  where：在扫描到的任何索引记录上加排它的next-key锁，还在主键聚集索引加排它的记录锁。
    - **注意如果过滤条件无法使用索引，因为加锁是引擎层面的行为，而无法使用索引的过滤是mysql服务器行为，引擎只能将所有记录加锁后返回**。
- insert into：在insert操作之前，会在索引记录之间加一个插入意向间隙锁，插入成功后会对插入行的索引记录上加一个排它记录锁。
    - **插入意向间隙锁目的是为了被间隙锁阻塞，插入意向间隙锁之间不会阻塞**。
    - 自增列innodb会在该索引的末位加一个排它锁，而为了访问这个自增的数值，需要加一个表级锁，不过这个表级锁的持续时间只有当前sql，而不是整个事务，即当前sql执行完，该表级锁就释放了。

##### 组合索引加锁

idx(a,b)

- **a**: 1 | 3 | 3 | 3 | 5
- **b**: 1 | 1 | 2 | 2 | 5
- **c**: 1 | 2 | 3 | 1 | 5
- **id**: 3 | 5 | 1 | 2 | 4

1. delete from t where a>1 and a<5 and b=2 and c=1：组合索引上，gap锁4个（a值1到5之间），X锁两个（b=2），聚簇索引X锁两个（id=1,2）

2. delete from t where a=3 and b>1 and c=1：组合索引上，gap锁3个（a值等于3且b值大于1），X锁两个（b=2），聚簇索引X锁两个（id=1,2）

#### 索引

#### 1. 索引类型

- B树索引
    - 使用B+树实现，有序存储，一般为1-3层，即可存储千万级的数据，非叶子结点只保存索引值，在叶子结点才保存被索引的数据。
    - 优点是减少了磁盘IO的次数，且每次查询都是稳定的，因为数据行到根节点的高度是相同的。

- 哈希索引
    - 使用哈希表实现，无序存储，查询快，但无法排序和范围搜索。
    - innnodb的自适应哈希索引，引擎会自发的在B树索引基础上对被频繁使用的索引值创建一个哈希索引，提高查找效率。

#### 2. 索引策略

- 聚簇索引：一种数据存储方式，将数据行和索引保存在一起，而不是通过指针指向数据行。
    - 一张表只能有一个聚簇索引，因为无法将数据同时保存在两个地方。
    - innodb的主键索引是聚簇索引，将数据行保存在B树索引的叶子结点中。
    - 优点是使用聚簇索引获取数据很快，缺点是更新聚簇索引的代价很高，会导致“页分裂”。

- 非聚簇索引：也称为二级索引，普通索引
    - innodb的二级索引在叶子结点保存的是主键值而不是指向行的指针，所以通过二级索引查找数据时需要两次b树查找。

- 唯一索引：索引值必须是唯一的，可以为Null，而主键索引不能为Null。

- 组合索引：多列索引
    - 将区分度高的索引放在左边，相当于建立了从最左列开始组合的多个多列索引。

- 覆盖索引：索引覆盖了查询的所有数据行，则不需要再去读取数据行，直接读取索引数据。

- 前缀索引：针对字符串列的索引不需要索引完整的字符串，只索引字符串前几位，以提升索引效率。
    - 对字符串字段使用前缀索引，且只能使用右模糊，因为左模糊无法使用索引。

### SQL优化

##### 字段某些特殊值占据了绝大部分的比例

``` text
status字段中值为0的数据比例超过90%，则status=0时强制不走索引idx_staus，因为加载该索引消耗更大。
select * from t ignore index (idx_stauts) where status = 0 limit 10;
```

##### 取出每个科目分数排名前2的数据

``` text
使用子查询
select * from 
table t0 
where (
    select count(*) from 
    table t1 
    where 
    t1.subject = t0.subject and t1.score > t0.score
    ) < 2

使用exists
select * from
table t0
where exists (
    select 1 from 
    table t1
    where 
    t1.subject = t0.subject and t1.score > t0.score
    having count(*) < 2)

以上两种方式是一样的，主表都是走全表查询，子查询会走subject索引
```
