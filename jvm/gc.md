# [首页](/blog/)

> 垃圾收集

***

## **对象存活判断**

- **引用计数算法**：在对象中添加一个引用计数器，计数器为零的对象就是不可能再被使用的，简单高效，但是难以解决相互引用的问题；
- **可达性分析算法**：Java虚拟机使用的算法，将GC Roots作为起始结点集，如果某个对象到GC Roots之间不存在引用链，则此对象是不可能再被使用的。Java中可以固定作为GC Roots的对象包括：
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象；
  - 本地方法栈中Native方法引用的对象；
  - 方法区中类静态属性引用的对象，如类的引用类型静态变量；
  - 方法区中常量引用的对象，如字符串常量池里的引用；
  - 虚拟机内部的引用，如基本数据类型的Class对象、常驻的异常对象、系统类加载器等；
  - 所有被同步锁持有的对象。

***

## **回收方法区**

Java虚拟机规范并不要求虚拟机在方法区实现垃圾收集，方法区的垃圾收集主要回收废弃的常量和不再使用的类型。**判断一个类型是否可以回收需要满足三个条件：该类所有实例都已被回收、加载该类的类加载器已经被回收、该类的Class对象没有在任何地方被引用**。

***

## **垃圾收集算法**

### **分代收集理论**

垃圾收集器将Java堆划分出不同的区域（一般至少分为新生代和老年代），然后将回收对象根据其年龄（熬过垃圾收集过程的次数）分配到不同的区域之中存储。建立在两个假设之上：绝大多数的对象都是朝生夕灭、熬过越多次垃圾收集过程的对象就越难以消亡。

- Partial GC：目标不是完整收集整个Java堆的垃圾收集；
- Minor GC/Young GC：目标只是新生代的垃圾收集；
- Major GC/Old GC：目标只是老年代的收集，**仅CMS有单独收集老年代的行为**；
- Mixed GC：目标是整个新生代及部分老年代的垃圾收集，**仅G1的收集行为**；
- Full GC：收集整个Java堆和方法区的垃圾收集。

### ***记忆集***
  
Remembered Set，**建立在新生代上的全局数据结构**，将老年代划分为若干小块，标记老年代哪一块内存存在跨代引用。**Minor GC时只有包含了跨代引用的小块内存里的对象才会被加入GC Roots进行扫描**，虽然会增一些维护记忆集的开销，但是收集时不用扫描整个老年代。

### **标记-清除算法**

首先标记所有需要回收的对象，在标记完成后统一回收所有标记的对象，也可以反过来标记存活的对象。缺点主要有：执行效率不稳定、内存空间碎片化。

### **标记-复制算法**

将内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块上面。为了解决标记-清除算法面对大量可回收对象时（新生代）执行效率低的问题，只需要复制占少数的存活对象，每次都是针对整个半区进行内存回收，实现简单运行高效，缺点是浪费了一半的空间。

### **标记-整理算法**

对于对象存活率高的区域（老年代），标记过程完成后，让所有存活的对象都向内存空间一端移动，然后直接清理掉边界之外的内存。**移动存活对象并更新所有对象的引用必须在Stop The World阶段进行**，相比清除算法，会增加程序的停顿时间，但会提高内存分配和访问的效率，使得总吞吐量提高。

***

## **HotSpot算法实现**

### **根节点枚举**

所有收集器在枚举根节点时**都必须暂停用户线程**，使用一组称为OopMap的数组结构获取**所有执行上下文和全局的引用中哪些地方存放着对象引用**。

### **安全点**

Safepoint，HotSpot只有在安全点才会生成OopMap，因为**只有当前程序执行到安全点时才能够停顿下来开始垃圾收集**，。在方法调用、循环跳转、异常跳转等指令位置才会产生安全点。HotSpot使用**内存陷阱保护方式**，当需要暂停用户线程时，将内存页设置为不可读，那线程执行指令时就会产生一个自陷异常信号，然后在异常处理器中挂起线程，只需要一条汇编指令就可以完成安全点轮询和触发线程中断。

### **安全区域**

安全点机制可以保证分配到处理器时间的用户线程进入安全点，处于Sleep或Blocked状态的用户线程需要引入安全区域来解决。安全区域即：**能够保证某一段代码片段之中引用关系不会发生变化，因为在这个区域的任意地方开始垃圾收集都是安全的**。用户线程执行到安全区域时会标记自己进入安全区域，当要离开安全区域时需要检查当前垃圾收集（需要暂停用户线程的阶段）是否已经完成，未完成则会一直等待直到收到可以离开安全区域的信号为止。

###  **Stop the world**

当所有线程都进入安全点或安全区域时，堆的状态才是确定的，可以执行垃圾收集、内存分析命令（jstack、jmap、jstat等）、取消偏向锁等。

### **记忆集和卡表**

记忆集是一种从非收集区域指向收集区域的指针集合的抽象数据结构，最简单的实现是非收集区域所有含跨代引用的对象数组。**卡表是最常用的一种记忆集的实现形式，卡表内每一个记录代表了一块内存区域**。HotSpot使用字节数组（类似bitmap）的方式实现，每一个字节对应着其标识的内存区域中的一个卡页（512字节大小的内存块），每个卡页内有一个或更多的对象的字段存在跨代指针，则将对应的卡表中的数组元素的值标识为1，没有则标识为0，垃圾收集时找出含有跨代指针的卡页加入GC Roots中一并扫描。

### **写屏障（非内存屏障）**

对卡表的更新维护需要在对象赋值的时间点，在编译执行的场景需要使用机器码层面的手段，“写屏障”。虚拟机层会为“引用类型字段赋值”动作生成一个环形通知，供程序执行额外的动作，垃圾收集器使用“写后屏障”完成卡表状态更新。

### **并发的可达性分析**

#### **三色标记法**

- 白色：表示对象未被垃圾收集器访问过，在可达性分析刚开始的阶段，所有对象都是白色，若在分析结束时的阶段，仍然是白色的对象则不可达。
- 黑色：表示对象已经垃圾收集器访问过，且这个对象所有的引用都已经扫描过。它是安全存活的，如果有其他对象指向黑色对象无须重复扫描，黑色对象也不可能直接指向某个白色对象。
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没被扫描过。根节点枚举阶段，**根节点引用的对象都是灰色的**。可达性分析结束的阶段不存在灰色对象。

#### **漏标**

并发标记过程中，用户线程修改了引用关系，导致原本应该是黑色的对象被标记为了白色，需要满足两个条件：插入了一条或多条从黑色对象到该白色对象的新引用、删除了全部从灰色对象到该白色对象的直接或间接引用。

- **增量更新**：CMS，破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时，将这个新插入的引用记录下来，等并发扫描结束后，再将记录过的引用关系中的黑色对象作为根，重新扫描一次。**即黑色对象一旦新插入指向白色对象的引用就会变回灰色对象**。使用“写后屏障”实现。
- **原始快照**：G1、Shenandoah，破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用记录下来，在并发扫描结束后，再将这些记录过的引用关系中的灰色对象作为根，重新扫描一次。**即无论引用关系是否删除都会按照开始扫描的那一刻的对象图像进行搜索**。使用“写前屏障”实现。

***

## **垃圾收集器**

###

***

### HotSpot JVM 堆内存分配策略

对年轻代会使用复制算法，老年代则使用标记整理或标记清除算法。

- **Minor GC**：新创建的对象会被分配到Eden区（大对象则直接分配到老年代），当Eden区内存不足时会执行Minor GC。将Eden区和From区（当前使用的Survivor区）中的存活对象复制到To区（当前空闲的Survivor区），From区的存活对象年龄会增加一岁，如果年龄达到阈值则被移动到老年代。
  - 动态年龄判断：如果Survivor区所有相同年龄的对象占用空间超过了一半会把大于等于该年龄的对象移动老年代。
  - 空间分配担保：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。
  - Card Table：卡表，为了提高新生代的回收效率，虚拟机使用卡表（比特位集合）来表示老年代某一区域中所有对象是否持有新生代对象的引用，这样就不用扫描所有老年代对象了，只需要扫描比特位被标记为1的区域即可。
- **Full GC / Major GC**：会包括年轻代GC，效率很低，并会阻塞程序。
  - System.gc() 方法的调用只是建议触发；
  - 老年代空间不足（声明大数组容易触发）；
  - 堆空间伸缩时触发；
  - 元空间不足；
  - 空间分配担保失败。
- 元空间清理：因为无法监控元空间的大小，只会在Full GC时顺便回收元空间，主要回收废弃常量和无用的类。

***

## ParNew & Parallel Scavenge

都是使用复制算法的多线程新生代垃圾收集器，ParNew 追求降低用户停顿时间；Parallel Scavenge 追求降低 CPU 吞吐量，是默认的新生代垃圾回收器。

***

## CMS

老年代垃圾收集器，并发收集，以最短的停顿时间作为目标（适用延时敏感服务）。对CPU资源有一定占用，吞吐量低；使用标记-清除算法，所以产生空间碎片，故会引发Full GC，重新整理内存，整理阶段也会发生STW。

分为Background GC和Foreground GC，前者为周期性任务，标记清除算法，后者则是相当于Full GC。

1. 初始标记：引发STW，单线程，只标记GC Roots直接关联到的对象，速度很快；
2. 并发标记：不引发STW，多线程，判断Old对象是否可达，时间长；
3. 重新标记：引发STW，多线程，修正并发标记期间程序运行导致的标记改变，比初始标记稍长；
4. 并发清理：不引发STW，单线程，清理被标记的可回收的对象，时间很长。

并发标记和并发清理较长，但不会造成工作线程暂停，而初始标记、重新标记时间很短，即只会造成工作线程短停顿。**CMS一般与ParNew组合使用**。相比G1的优势是清理阶段不需要STW，适用于高并发对响应时间要求极高的场景。

***

## G1 GC

特性包括：充分利用多核性能、分代收集、空间整合、可预测停顿。

- Region：将堆内存分区，每个区大小为1-32M（必须是2的幂次方），有四种标签：Eden、Survivor、Old、Humongous（对象大小超过0.5区域大小时放到H区，超过区域大小则放到连续的H区）。
- RememberSets：每个区域都有一个RSet，用于记录本区域中所有对象引用的对象所在的区域；
- CollectionSets：一次GC中需要被清理的Region集合，及每次GC只需要扫描CSet中的RSet即可。

### 分代收集

- Young GC：【-XX:MaxGCPauseMillis】配置表示每次YGC/MixedGC的期望最长停顿时间，会按此配置执行回收；Young GC会回收所有年轻代区域，会通过控制年轻代区域的个数以实现控制垃圾收集的开销；
  
- Mixed GC：同时回收新生代加老年代区域，【-XX:InitiatingHeapOccupancyPercent】配置表示当老年代占用比例超过该值后，执行Mixed GC替代Young GC，默认45%；Mixed GC还会回收经过并发标记统计后，确定出的回收益最高的老年代区域；
  
- Old GC：实际上没有Full GC的概念，因为是基于复制算法，当 Young GC/Mixed GC 执行时无法找到空闲的region时就会失败，**一旦失败就会立刻停止系统程序切换到 G1 之外的 Serial Old GC 来收集整个堆（包括 Young、Old、Metaspace）**，其性能等同于串行收集器。

### 收集过程

- 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记；
- 并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢；
- 最终标记：Stop The World，使用多条标记线程并发执行；
- 筛选回收：回收废弃对象，此时也要 Stop The World，并根据用户期望的时间使用多条筛选回收线程并发执行。

***

## ZGC

使用【-XX:+UseZGC】开启，优势是非常小的停顿时间且与堆大小和活跃对象数量无关，支持TB级别的堆大小。

***