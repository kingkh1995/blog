# [首页](/blog/)

> 垃圾回收

***

## 对象存活判断

- 引用计数法：为对象添加一个引用计数器，计数器不为0则表示存活，优点是判断高效，缺点是循环引用无法解决；
- 可达性分析：从GC Roots出发如果可达则存活，GC Roots包括：Java方法栈和本地方法栈中引用的对象、方法区常量引用的对象、方法区中静态属性引用的对象。

***

## 垃圾回收算法

- 标记清除算法：先标记，标记完成后再清理，会产生大量的不连续内存碎片，且标记和清除效率都不高；
- 标记整理算法：老年代算法，先标记，标记完成后将存活的对象整理到空间另一端，移动非复制；
- 复制算法：新生代算法，分成两块空间，每次只使用一块，将存活的对象复制到空闲的空间内，再清除已使用的空间，缺点就是浪费空间。
- 分代收集算法：新生代使用复制算法，老年代使用标记清除或标记整理算法。

### *三色标记法*

CMS、G1和ZGC使用，从GC Roots开始进行遍历访问对象，白色表示未访问过，黑色表示访问过且该对象引用的所有对象都已访问完成，灰色表示已访问过但引用对象尚未访问完，最终会变为黑色。

1. 初始所有对象都在白色集合内；
2. **GC Roots直接引用的对象会被加入灰色集合**；
3. 从灰色集合获取对象，第一步将当前对象直接引用的对象放入灰色集合，然后将当前对象移到黑色集合；
4. 重复以上步骤直到灰色集合为空，然后可以尝试回收白色集合内剩余的对象。

#### 漏标和浮动垃圾

在并发标记阶段由于用户线程操作带来的引用变化导致标记出现问题，漏标表示本来可达的对象被遗漏标记，这种是不能被接受的错误，CMS的重新标记和G1的最终标记阶段即是用于解决这种问题；浮动垃圾表示不可达的对象被标记为了黑色，这种一般不需要处理。

#### 三色标记法的漏标

某个白色对象本来被某个灰色对象引用，在扫描完某个黑色对象后，将该白色对象的引用从灰色对象转移到黑色对象上，由于三色标记原理，则黑色对象不会被再次扫描，故该白色对象被漏标。

- 增量更新：CMS，相当于在黑色对象增加白色引用后，将其再次标记为灰色，缺点就是需要重新扫描，比较浪费时间。
- 原始快照：G1，相当于在灰色对象取消白色引用后，将白色对象变为灰色，缺点就是该对象最终会变成黑色，即称为了浮动垃圾，本次GC会存活。

### HotSpot JVM 堆内存分配策略

对年轻代会使用复制算法，老年代则使用标记整理或标记清除算法。

- **Minor GC**：新创建的对象会被分配到Eden区（大对象则直接分配到老年代），当Eden区内存不足时会执行Minor GC。将Eden区和From区（当前使用的Survivor区）中的存活对象复制到To区（当前空闲的Survivor区），From区的存活对象年龄会增加一岁，如果年龄达到阈值则被移动到老年代。
  - 动态年龄判断：如果Survivor区所有相同年龄的对象占用空间超过了一半会把大于等于该年龄的对象移动老年代。
  - 空间分配担保：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。
  - Card Table：卡表，为了提高新生代的回收效率，虚拟机使用卡表（比特位集合）来表示老年代某一区域中所有对象是否持有新生代对象的引用，这样就不用扫描所有老年代对象了，只需要扫描比特位被标记为1的区域即可。
- **Full GC / Major GC**：会包括年轻代GC，效率很低，并会阻塞程序。
  - System.gc() 方法的调用只是建议触发；
  - 老年代空间不足；
  - 元空间不足；
  - 空间分配担保失败；
  - 统计得到的 Minor GC 晋升到老年代的平均大小大于老年代的剩余空间。
- 元空间清理：因为无法监控元空间的大小，只会在Full GC时顺便回收元空间，主要回收废弃常量和无用的类。

### SafePoint

表示堆对象的状态是确定的，可以安全的执行GC操作、堆dump及释放偏向锁，线程被阻塞及执行JNI方法时都位于safepoint。

如果是hotspot JVM，解释执行时每条字节码都可以是一个安全点，编译执行会在每个方法返回前和非计数循环（for）的回跳前设置安全点。

***

## ParNew & Parallel Scavenge

都是使用复制算法的多线程新生代垃圾收集器，ParNew 追求降低用户停顿时间；Parallel Scavenge 追求降低 CPU 吞吐量，是默认的新生代垃圾回收器。

***

## CMS

老年代垃圾收集器，并发收集，以最短的停顿时间作为目标。对CPU资源有一定占用，吞吐量低；使用标记-清除算法，所以产生空间碎片，故会引发Full GC，重新整理内存，整理阶段也会发生STW。

1. 初始标记：引发STW，单线程，只标记GC Roots直接关联到的对象，速度很快；
2. 并发标记：不引发STW，多线程，判断Old对象是否可达，时间长；
3. 重新标记：引发STW，多线程，修正并发标记期间程序运行导致的标记改变，比初始标记稍长；
4. 并发清理：不引发STW，单线程，清理被标记的可回收的对象，时间很长。

并发标记和并发清理较长，但不会造成工作线程暂停，而初始标记、重新标记时间很短，即只会造成工作线程短停顿。

***

## G1 GC

特性包括：充分利用多核性能、分代收集、空间整合、可预测停顿。

- Region：将堆内存分区，每个区大小为1-32M（必须是2的幂次方），有四种标签：Eden、Survivor、Old、Humongous（对象大小超过0.5区域大小时放到H区，超过区域大小则放到连续的H区）。
- RememberSets：每个区域都有一个RSet，用于记录本区域中所有对象引用的对象所在的区域；
- CollectionSets：一次GC中需要被清理的Region集合，及每次GC只需要扫描CSet中的RSet即可。

### 分代收集

- Young GC：【-XX:MaxGCPauseMillis】配置表示每次YGC/MixedGC的期望最长停顿时间，会按此配置执行回收；Young GC会回收所有年轻代区域，会通过控制年轻代区域的个数以实现控制垃圾收集的开销；
  
- Mixed GC：同时回收新生代加老年代区域，【-XX:InitiatingHeapOccupancyPercent】配置表示当老年代占用比例超过该值后，执行Mixed GC替代Young GC，默认45%；Mixed GC还会回收经过并发标记统计后，确定出的回收益最高的老年代区域；
  
- Old GC：实际上没有Full GC的概念，因为是基于复制算法，当 Young GC/Mixed GC 执行时无法找到空闲的region时就会失败，**一旦失败就会立刻停止系统程序切换到 G1 之外的 Serial Old GC 来收集整个堆（包括 Young、Old、Metaspace）**，其性能等同于串行收集器。

### 收集过程

- 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记；
- 并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢；
- 最终标记：Stop The World，使用多条标记线程并发执行；
- 筛选回收：回收废弃对象，此时也要 Stop The World，并根据用户期望的时间使用多条筛选回收线程并发执行。

***

## ZGC

使用【-XX:+UseZGC】开启，优势是非常小的停顿时间且与堆大小和活跃对象数量无关，支持TB级别的堆大小。

***