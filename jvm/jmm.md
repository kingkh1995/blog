# [首页](/blog/)

> Java内存模型

***

## Java Memory Model

用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。

- 调用栈和本地变量存放在线程栈上，对象存放在堆上。
- 对象方法中的本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。
- 对象的成员变量**可能**随着这个对象自身存放在堆上（对象逃逸分析）。
- 静态成员变量跟随着类定义一起存放在堆上。、
- **线程使用堆内存中的变量时，需要将其复制到本地内存中（为抽象概念，包括缓存，缓冲区，寄存器等）。**
- **JMM不保证对没有被volatile修饰的64位的long型和double型变量的写操作具有原子性（因为在32位系统中需要两次操作）。**

***

## 指令重排序

是减少CPU中断的一种技术，其可以保证结果与顺序执行的结果一致，但是没有义务保证与并行执行的结果一致。

- 编译器优化重排：不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令并行重排：不存在数据依赖性情况下，改变语句对应的机器指令的执行顺序，以将多条指令重叠执行。
- 内存系统重排：由于处理器使用缓存和读/写缓存冲区，这使得加载和存储操作看上去可能是在乱序执行。

***

## 原子性变量操作

- lock（锁定）：作用于主内存变量，把一个变量标识为线程独占状态。
- unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load（载入）：作用于工作内存变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存变量，它把一个从执行引擎接收到的值赋值给工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- write（写入）：作用于主内存变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

***

## happens-before

如果操作A happen before 操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。

**这并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行，只要保证重排序之后的执行结果与按happens-before关系来执行的结果一致即可**。

***

## volatile

- 保证变量可见性
  - 修改变量会立即把值刷新到主内存；
  - 使用变量每次都会从主内存中读取。
  
- 禁止变量重排序：通过内存屏障实现
  - 每个写操作前插入一个StoreStore屏障，之后插入一个StoreLoad屏障；
  - 每个volatile读操作后先插入一个LoadLoad屏障，再插入一个LoadStore屏障。

***