# [首页](/blog/)

***

## JMM
JMM规定，线程间共享变量保存于堆内存中，线程使用共享变量时，需要将其复制到本地内存（为抽象概念，包括缓存，缓冲区，寄存器等）。

### 重排序
指令重排就是减少CPU中断的一种技术，指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。

- 编译器优化重排：不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令并行重排：不存在数据依赖性情况下，改变语句的机器指令执行顺序，以将多条指令重叠执行。
- 内存系统重排：由于处理器使用缓存和读写缓存冲区，使得内存与缓存的数据同步存在时间差，就像是乱序执行一样。

### 未同步程序在JMM和顺序一致性内存模型中的执行特性有如下差异
- 顺序一致性保证单线程内的操作会按程序的顺序执行；JMM不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是JMM保证单线程下的重排序不影响执行结果）
- 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。（因为JMM不保证所有操作立即可见）
- 顺序一致性模型保证对所有的内存读写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性（因为在32位系统中需要两次操作）。

### happens-before
如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程，**但这并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行，只要重排序之后的执行结果，与按happens-before关系来执行的结果一致即可**。

### volatile
- 保证变量可见性：写操作会理解把值刷新到主内存，读操作每次都会从主内存中读取。
- 禁止变量重排序：通过内存屏障实现，在每个volatile写操作前插入一个StoreStore屏障；在每个volatile写操作后插入一个StoreLoad屏障；在每个volatile读操作后插入一个LoadLoad屏障；在每个volatile读操作后再插入一个LoadStore屏障。