# [首页](/blog/)

> Java内存模型

***

## Java Memory Model

用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。

- 调用栈和本地变量存放在线程栈上，对象存放在堆上。
- 对象方法中的本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。
- 对象的成员变量**可能**随着这个对象自身存放在堆上（对象逃逸分析）。
- 静态成员变量跟随着类定义一起存放在堆上。、
- **线程使用堆内存中的变量时，需要将其复制到本地内存中（为抽象概念，包括缓存，缓冲区，寄存器等）。**
- **JMM不保证对没有被volatile修饰的64位的long型和double型变量的写操作具有原子性（因为在32位系统中需要两次操作）。**

***

## 指令重排序

是减少CPU中断的一种技术，其可以保证结果与顺序执行的结果一致，但是没有义务保证与并行执行的结果一致。

- 编译器优化重排：不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令并行重排：不存在数据依赖性情况下，改变语句对应的机器指令的执行顺序，以将多条指令重叠执行。
- 内存系统重排：由于处理器使用缓存和读/写缓存冲区，这使得加载和存储操作看上去可能是在乱序执行。

***

## 原子性变量操作

- lock（锁定）：作用于主内存变量，把一个变量标识为线程独占状态。
- unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load（载入）：作用于工作内存变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存变量，它把一个从执行引擎接收到的值赋值给工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- write（写入）：作用于主内存变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

***

## happens-before

如果操作A happen before 操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。

**这并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行，只要保证重排序之后的执行结果与按happens-before关系来执行的结果一致即可**。

***

## volatile

- 保证变量可见性
  - 修改变量会立即把值刷新到主内存；
  - 使用变量每次都会从主内存中读取。
  
- 禁止变量重排序：通过内存屏障实现
  - 每个写操作前插入一个StoreStore屏障，之后插入一个StoreLoad屏障；
  - 每个volatile读操作后先插入一个LoadLoad屏障，再插入一个LoadStore屏障。

- 同步也能保证变量的可见性，可以将对volatile修饰变量的读取视作加上了同步的get和set方法，只能不需要加锁操作。

### 内存屏障

屏障之前和之后的代码不能交换执行顺序，读屏障会使得高速缓冲区的数据失效强制重新从主内存中加载数据，写屏障会让写入缓存中的最新数据写入主内存，以此对其他线程可见。

- LoadLoad：后面的load操作的数据被访问前，前面的load操作的数据已经读取完毕；
- LoadStore：后面的store操作写入前保证前面的store操作写入的值对其他线程可见；
- StoreStore：后面的store操作写入前保证前面的load操作的数据已经读取完毕；
- StoreLoad：万能屏障，包括前面三种。

***

## 既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile关键字？

MESI协议是用来保证多核CPU的cache一致性，但CPU并没有严格遵守，因为会降低执行效率；而volatile是Java语言的保证，用来防止指令重排，无论是单核还是多核都需要。

```java
public class Demo {
    private static boolean running = true;
    private static int count = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            while (running) {
                count++;
            }
        });
        Thread t2 = new Thread(() -> running = false);
        t1.start();
        Thread.sleep(1000);
        t2.start();
        t1.join();
        t2.join();
    }
}
```
此代码运行结果是t1线程会进入死循环无法退出，解决方案是使用volatile修饰running；**但并不是因为可见性的原因导致**，而是由于JIT优化，t2线程修改running值前，t1线程已经运行了1秒中，t1中的代码会被判断热点代码，进而直接将running替换为true，导致代码进入死循环；如果关闭掉JIT优化或者注释掉sleep代码，由于CPU缓存一致性协议，最终t1仍会读取到最新的running值并退出循环。

***

## 安全发布

### 不正确的发布
```java
public Holder holder;

public void init() {
    holder = new Holder(42);
}

public class Holder {
    private int n;

    pulic Holder(int n) { 
        this.n = n; 
    }

    public void assert() {
        if (n != n) {
            throw new AssertError();
        }
    }
}
```
多线程执行assert方法时可能抛出异常，因为域 n 不是 final 的，在Object的构造函数中会先将默认值0写入 n 中。

### 安全发布对象的方式

- 在静态初始化函数中初始化对象；
- 将对象的的引用保存在volatile类型的域或AtomicRefrence对象内；
- 将对象的引用保存在final类型域中；
- 将对象的引用保存到一个由锁保护的域中。

***