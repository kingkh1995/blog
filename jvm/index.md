# [首页](/blog/)

> <<深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）>>

***

## 内存结构

### 程序计数器

程序计数器是一块较小的内存空间，为线程私有，是当前线程正在执行的那条字节码指令的地址；若当前线程正在执行的是一个本地方法，那么此时程序计数器为Undefined；**唯一不会产生OOM的区域**。

### Java虚拟机栈

线程私有，每一个运行的Java方法都有一块自己的栈帧，用于存放该方法运行过程中的一些信息，如局部变量表、操作数栈、动态链接、方法出口信息等。

- 局部变量表：容量大小是在编译期就可以确定下来，最基本的存储单元是slot（4个字节），**局部变量表中的变量也是重要的GC Roots**；
- 操作数栈：其最大深度也是在编译期就确定好的，每32bit占用一个栈单位深度；
- 动态链接：被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用；按照继承关系从下往上依次对当前类的各个父类进行搜索和验证，直到找到这个方法的直接引用；
- 方法出口地址：方法被调用的位置。
  
### 本地方法栈

线程私有，为本地方法准备的空间，与Java虚拟机栈类似。

### 堆

线程共享，每个JVM进程只有一个堆，在虚拟机启动时创建，是垃圾回收的主要场所。

#### TLAB

Thread Local Allocation Buffer，即线程本地分配缓存区，属于 Eden 区，这是一个线程私有的内存分配区域，线程私有；堆是全局共享的，在同一时间，可能会有多个线程在堆上申请空间，在给对象分配内存时，每个线程可以使用自己的 TLAB，这样就不需要进行同步了（虚拟机使用CAS的方式进行同步），如果失败了就会使用加锁的机制来保持操作的原子性。

### 方法区

方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的，整个虚拟机中只有一个方法区。存放以下信息：已经被虚拟机加载的类信息、常量、静态变量即时编译器编译后的代码；

#### 永久代和元空间

**永久代和元空间（JDK8）都是对方法区的实现，永久代位于虚拟机内存，而元空间位于本地内存，本地内存同时还包括了直接内存（DirectBuffer）。**

#### 类常量池和运行时常量池

在编译的阶段，每个类都有一个类常量池，存放各种字面量（定义的常量）和符号引用（类名、方法名、字段名等），加载阶段，会为每个类创建一个运行时常量池，加载过程中将字面量加入，类加载完成之后将符号引用值加入，类在解析之后，再将符号引用替换成直接引用。

***

## 类加载

### 类的生命周期

加载 -> 连接（验证->准备->解析）-> 初始化 -> 使用 -> 卸载

- 加载：
    1. 获取类文件的二进制流；
    2. 转化为方法区的运行时结构；
    3. 创建Class对象。
- 验证：确保类文件的字节流符合当前虚拟机的要求，不造成安全错误；
- 准备：为类静态成员变量分配内存并设置初始值，完成内存结构布局；
- 解析：将运行常量池内的符号引用替换为直接引用，**由于运行时绑定机制可能在初始化之后开始**；
- 初始化：类加载过程的最后一步，执行类构造器\<clinit\>方法，**只有主动引用才会触发类的初始化**。
- 使用：为对象分配空间和初始化。

### 类加载器

- BootstrapClassLoader：启动类加载器，为JVM启动时创建的加载器，无法被获取，用于加载Java的类（\<JAVA_HOME\>/lib目录下）；

- PlatformClassLoader：平台加载器，JDK9替代了拓展加载器，用于加载拓展的系统类，如Java SE平台API及其实现类、特定的JVM运行时所需的类等；

- SystemClassLoader：系统加载器，也称为应用加载器，用于加载用户路径下的所有类。

### 双亲委派模型

除了顶层的Bootstrap外，其余的类加载器都应当有自己的父类加载器，类加载器之间具有等级制度但不是继承关系。要求当一个类加载器收到了类加载的请求后会向上委托父加载器加载，直到父加载器无法完成该加载请求，才会尝试自己去加载。

### JAVA主动破坏双亲委派模型

1. 1.2才新增的双亲委派的逻辑在loadClass方法中，为了向前兼容不是final方法，只需要重写即可破坏；
2. JNDI、JDBC等在classpath路径下，因此为Thread对象增加了getContextClassLoader()方法，启动类加载器使用该方法获取应用加载器以加载用户的具体实现；
3. 引入模块化后，新增final loadClass(Module module, String name)方法，其实现为直接使用findClass方法加载，然后判断类所属模块是不是给定模块，相同才返回。

### 要点

- 数组类对象不是由类加载器创建的，而是运行时由JVM创建的；
- 对象数组的类加载器与其元素的类加载器相同；
- 基本数据类型和基本数据类型数组没有类加载器。

***

## 对象

分为对象头、实例数据、Padding。

- 对象头：包括markword（4字节）和class对象指针（4字节），markword包含哈希码、GC 分代年龄、锁状态标志，偏向锁标识（已废弃），如果是数组还包括数组长度；
- 实例数据：成员变量的值，包括父类和自身；
- Padding：对齐补充，用于确保对象的总长度为 8 字节的整数倍

### 访问方式

- 句柄访问方式：堆中需要额外的句柄池，每一个句柄包含了对象实例数据与类型数据各自指针，而引用变量保存的则是句柄地址；优点是速度快，在对象被移动时（GC中）只需要改变句柄中实例数据的指针即可。
- 直接指针访问方式：引用变量直接存放对象地址，即HotSpot的方式；优点是速度快，因为只需要一次指针定位。

## 逃逸分析

- 同步省略：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

- 将堆分配转化为栈分配：如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

- 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。

***

## OutOfMemoryError

### java.lang.StackOverflowError：线程栈空间耗尽

最常见的就是由无限递归导致（如两个对象循环依赖然后调用toString方法），如确实需要，可以通过JVM启动参数（-Xss）适当增大增加线程栈内存空间。

### Java heap space：堆内存空间不足

最常见的错误。首先需要检测是否出现内存泄漏；然后判断是否是创建了超大对象（或数组），检查该逻辑是否合理；如果是突发流量，则填谷削峰、限流降级；如果确实是业务压力增大，则通过JVM启动参数（-Xmx）调大堆内存，或新增资源。

### GC overhead limit exceeded：垃圾回收上头

进程花费98%以上的时间执行GC，但只恢复了不到2%的内存，且该动作连续重复了5次，**可能会先触发Java heap space**。使用和Java heap space相同的方案排查问题。

### Direct buffer memory：本地内存不足

使用 DirectBuffer（ByteBuffer等）可以直接访问堆外内存以实现高速IO，省去了在Java堆和本地内存之间来回复制数据的消耗。其垃圾回收也是由GC负责，但是只能通过Full GC回收。首先也是需要检查是否存在内存泄漏，否则通过启动参数（-XX:MaxDirectMemorySize）增加可分配的堆外内存上限值，或增加服务器内存。

### Unable to create new native thread：JVM向操作系统请求创建本地线程失败

可能是线程数超过了操作系统最大线程数限制，需要检查创建的线程数量是否合理；或本地内存不足，则增加内存即可。

### Metaspace：元空间内存不足

加载的类数目太多或体积太大导致，运行时会生成大量动态类的应用场景下可能出现，可以调整为不限制元空间大小或增加其初始空间。

### Requested array size exceeds VM limit：超出了JVM限制的数组的最大长度

一般会比Integer.MAX_VALUE略小，一般很难出现，需要检查代码。

### Out of swap space：本地交换空间不足

表示所有可用的虚拟内存已被耗尽（**虚拟内存由物理内存和交换空间组成**），一般很难出现。

### Kill process or sacrifice child：被操作系统‘杀死’

Linux内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源，而当内存不足时，将自动激活OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。升级服务器配置/隔离部署，或优化OOM Killer。

***
