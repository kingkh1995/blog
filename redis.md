# [首页](/blog/)

> redis

***

## 特性

纯内存存储、IO多路复用、单线程架构。

***

## 数据结构及编码方式

- string：int（整型）、embstr（简单动态字符串）、raw
- hash：ziplist、hashtable
- list：quicklist，是结合了ziplist和linkedlist的优势的数据结构，为ziplist节点组成的linkedlist。
- set：intset（整数集合）、hashtable。
- zset：ziplist、skiplist。

### *编码方式*

- ziplist：为连续存储的顺序结构，目的是为了节省内存。虽然其复杂度为o(n)，但因为是连续的内存空间，所以可以利用CPU缓存大幅提高性能。
- skiplist：多层结构链表，相比于红黑树实现简单但占用更多的内存，查找效率可比拟二叉查找树，同时适合范围读取。

***

## 其他功能

- pipeline：用于批量执行多个命令，能有效节约RTT，相比于原生批量命令，pipeline是非原子性的。
- Bitmaps：位操作，底层为字符串。
- HyperLogLog：基数算法，底层为字符串。
- Geo：地理信息功能，使用geohash和zset数据结构实现。
- pub/sub：消息队列，适合可靠性要求低的简单场景。

***

## 事务

使用multi命令可开启事务，之后所有的命令会被加入一个事务队列中，所有命令均只会返回QUEUED表示命令已经入队，最后使用exec命令退出事务，此时会顺序执行事务队列中的所有命令，并返回所有结果，或使用discard命令放弃该事务，所有命令都会被丢弃。在事务开启前可以使用watch命令监听指定的键，事务执行前会检查被监听的键是否被修改，如果被修改会抛出异常，导致事务无法执行。

### *ACID*

- 原子性：不具备真正的原子性，如果命令错误则整个事务都不会执行，此场景具备原子性，但如果是运行时错误（操作错误）事务会继续执行下去无法回滚，此场景无原子性；
- 一致性：由redis保证；
- 隔离性：事务为串行执行的，故多个事务之间可以保证隔离性；
- 持久性：由redis持久化机制保证。

### *涉及到逻辑处理的事务*
- 方案：首先监听本次事务涉及到的键，然后执行查询命令执行逻辑处理确定需要执行的命令，最后开启事务执行命令。
- 分析：相当于使用了乐观锁，对键的监听能保证不会出现并发问题，缺点就是在并发效率低，且粒度过大。

***

## Lua
通过lua脚本可以执行redis命令，高效且是原子性的，同时可以被缓存以实现复用，绝大多数情况下都应该使用lua脚本替代事务。

***

## 持久化

### RDB

为当前进程数据生成快照保存，优点是恢复时间快，缺点是成本高且无法做到实时持久化。包括save和bgsave命令，save命令会阻塞redis，不建议使用；bgsave命令会fork一个子进程，只有在fork阶段才会阻塞redis，为主流方式。

#### *bgsave流程*

执行bgsave，会先判断当前是否存在bgsave命令，存在则直接返回；之后执行fork，过程中会阻塞父进程，fork完成后，不再阻塞父线程；子进程使用copy-on-write机制与父进程共享内存，根据父进程内存生成临时快照文件，完成后对原文件进行原子替换；完成后发送信号通知父进程，父进程更新统计信息。

### AOF

以独立日志的方式记录每次写命令，通过重新执行aof文件中的命令以恢复数据，用于解决持久化实时性，缺点是恢复慢。所有写命令以文本协议格式追加到aof缓冲区，根据指定的策略（一般使用everysec）将缓冲区同步到磁盘的aof文件，同时定期会对aof文件重写，以防止文件过大。、

***

## 主从复制流程

- 保存主节点信息
- 主从建立socket连接
- 发送ping命令
- 权限验证
- 根据偏移量同步数据集
- 命令持续异步复制

***

## redis内在阻塞问题

- 不合理的使用命令，通过使用slowlog命令分析慢查询；
- cpu饱和，可由命令执行效率下降引起，如放宽ziplist的条件导致过去内存优化；
- 持久化阻塞，内存实例过大可能导致fork阻塞，硬盘压力过大可能导致fsync阻塞。

***

## 内存回收策略

### 过期键删除策略

- 惰性删除，读取到超时键时才删除
- 定时删除，定时删除过期的键

### 内存溢出控制策略

- noeviction：默认策略，不删除。
- volatile-lru：使用lru算法，只删除过期的键
- allkeys-lru：使用lru算法，可删除所有键
- volatile-random：随机删除，只删除过期的键
- allkeys-random：随机删除，可删除所有键
- volatile-ttl：按ttl属性排序删除，包括还没过期的数据提前删除
- volatile-lfu：使用lfu算法，只删除过期的键
- allkeys-lfu：使用lfu算法，可删除所有键

***

## 哨兵

相比于主从架构，增加了多个哨兵节点，哨兵节点也是redis实例，但是不存储数据。每一个哨兵节点都会监控所有节点和其他哨兵节点，当节点失效会将其标记为下线，如果下线的是主节点，则多个哨兵节点会推选出一个来完成故障转移，并通知到应用方。

***

## 集群

由多个节点组成，包括主节点和对应的从节点，每个节点负责整体数据的一个子集，集群中主节点才负责读写请求和集群维护，从节点只进行主节点数据和状态信息的复制并在主节点故障时替换主节点。使用虚拟槽分区，范围为0-16383，解耦了数据和节点的关系，便于节点扩容和收缩，由节点自身维护槽的映射关系，同时集群模式也只允许使用0号数据库。节点间通信使用Gossip协议，即节点间彼此不断通信交换信息，每个节点额外开启一个通信端口并在固定的周期内根据一定的规则选择几个节点通信，整个集群是最终一致性的。

***