# [首页](/blog/)

> Effective Coding

***

## CODING

- 单例模式要防止被反射机制访问私有构造器，私有构造器**要保证创建第二个对象时能抛出异常**。

- if-else不要嵌套，代码块少于3行使用卫语句（**fail-fast**），否则使用策略模式。

- 组合使用if-else、switch和策略模式，**超高频条件使用if判断**。

***

## JAVA

- 集合作为参数时，如果只会取出元素使用<? extend E>上边界限定，如果只会添加元素使用<? super E>下边界限定。
  
- 使用集合的时候最好手动指定初始容量，**尤其是能预测到数据量会很大的情况下**。
  > 特别是ArrayList，其初始容量只有10，每次扩大为1.5倍，如果数据量很大，会频繁扩容。

- 使用ThreadLocal要手动调用remove()方法，web请求可以考虑使用Spring提供的RequestContextHolder（请求结束后会清空上下文信息），因为线程池会复用线程，如果不手动移除会造成内存泄漏。

- 不要在多线程中使用ThreadLocal的set/remove，因为CallerRunsPolicy拒绝策略以及展开的ForkJoinTask会在任务提交线程执行任务，这种情况下会导致上下文丢失。

***

## MYSQL

- 被索引的字段**要设置为非空**。 
  > NULL值处理比较复杂，但 IS NULL 和 IS NOT NULL 是有几率走索引的。

- IN & NOT IN 要慎用，都可能导致索引失效。
  > IN & NOT IN 都可能走索引。

- COUNT(*) & COUNT(1) 效率是完全一样的。
  
***

## 技术方案

- 重试时间、延迟时间、缓存持续时间等**要使用随机值**，且重试时间要随重试次数逐渐增加。 
  > 防止雪崩效应。

- 对外暴露的数据模型中不要使用自定义枚举。
  > 如果修改了枚举且引用方未更新版本，**有出现转化异常的风险**，正确的方式是通过@see方式提示字段对应的枚举值，由引用方自行转换。

***

